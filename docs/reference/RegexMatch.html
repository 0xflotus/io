<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
		<html>
		<head>
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
		<title>Io Reference Manual</title>
		<META HTTP-EQUIV="EXPIRES" CONTENT=0>
		<link rel="stylesheet" href="../docs.css">
		</head>
		<body>
		
<br><br><br>
<table cellspacing=4 style="width:45em; line-height:1.2em;">
<tr>
<td>
<a name=RegexMatch></a><span class=protoName>RegexMatch</span>
</td>
<td></td>
<td>
</tr>
<tr>
<td align=right><b><span class=protoModule>module</span></b></td>
<td></td>
<td>Regex</td></tr>
<tr>
<td align=right><b><span class=protoCategory>category</span></b></td>
<td></td>
<td>Parsers
</td></tr>
<tr>
<td align=right><b><span class=protoDescription>description</span></b></td>
<td></td>
<td>Contains the result of a regular expression match operation.
It acts as a read-only list of captured strings.
The first item is the entire matched string.
Each item after that is a captured sub pattern (anything inbetween
parenthesis in the pattern).

<pre>
Io> match := "37signals" findRegex("([0-9]+)([a-z]+)(!!)?")
==> RegexMatch: "37signals" 

# Item 0 is the entire matched string:
Io> match at(0)
==> 37signals

# Item 1 is the first capture ("[0-9]+"):
Io> match at(1)
==> 37

# Item 2 is the second capture ("[a-z]+"):
Io> match at(2)
==> signals

# The third sub pattern wasn't part of the match, so item 3 is nil:
Io> match at(3)
==> nil

# You can access captures by name:
Io> match at("number")
==> 37
Io> match at("word")
==> signals
</pre>
</td></tr>
<tr><td colspan=2>&nbsp;</td></tr>
<tr>
<td align=right>
<h3>index</h3>
</td>
<td></td>
<td>
<a href="#RegexMatch-asString">
asString
</a><br>
<a href="#RegexMatch-at">
at()
</a><br>
<a href="#RegexMatch-captures">
captures
</a><br>
<a href="#RegexMatch-end">
end
</a><br>
<a href="#RegexMatch-endOf">
endOf()
</a><br>
<a href="#RegexMatch-expandTo">
expandTo()
</a><br>
<a href="#RegexMatch-foreach">
foreach()
</a><br>
<a href="#RegexMatch-indexOf">
indexOf()
</a><br>
<a href="#RegexMatch-map">
map()
</a><br>
<a href="#RegexMatch-nameOf">
nameOf()
</a><br>
<a href="#RegexMatch-names">
names
</a><br>
<a href="#RegexMatch-postfix">
postfix
</a><br>
<a href="#RegexMatch-prefix">
prefix
</a><br>
<a href="#RegexMatch-range">
range
</a><br>
<a href="#RegexMatch-rangeOf">
rangeOf()
</a><br>
<a href="#RegexMatch-ranges">
ranges
</a><br>
<a href="#RegexMatch-regex">
regex
</a><br>
<a href="#RegexMatch-select">
select()
</a><br>
<a href="#RegexMatch-size">
size
</a><br>
<a href="#RegexMatch-sizeInChars">
sizeInChars
</a><br>
<a href="#RegexMatch-slice">
slice()
</a><br>
<a href="#RegexMatch-start">
start
</a><br>
<a href="#RegexMatch-startOf">
startOf()
</a><br>
<a href="#RegexMatch-string">
string
</a><br>
<a href="#RegexMatch-subject">
subject
</a><br>
</td>
</tr>
<tr><td colspan=2>&nbsp;</td></tr>
<tr>
<td align=right>
<h3>slots</h3>
</td>
<td></td>
<td>
<a name="RegexMatch-asString"></a><b>
asString
</b>
<p>
<div class=slotDescription>
Returns a string containing a textual representation of the receiver.
</div>
<a name="RegexMatch-at"></a><b>
at(indexOrName)
</b>
<p>
<div class=slotDescription>
Returns the capture with the given index or name. <code>at(0)</code> is the entire match.
</div>
<a name="RegexMatch-captures"></a><b>
captures
</b>
<p>
<div class=slotDescription>
Returns a list of captured strings. The first element is the whole match.
</div>
<a name="RegexMatch-end"></a><b>
end
</b>
<p>
<div class=slotDescription>
Returns the index into the subject at which the match ends.
</div>
<a name="RegexMatch-endOf"></a><b>
endOf(indexOrName)
</b>
<p>
<div class=slotDescription>
Returns the index into the subject at which the capture with the given index or name ends.
</div>
<a name="RegexMatch-expandTo"></a><b>
expandTo(templateString)
</b>
<p>
<div class=slotDescription>
Returns <em>templateString</em> with capture placeholders replaced with what they represent.
	<code>$0</code> is replaced with the whole match, <code>$1</code> is replaced with the first
	sub capture, etc. <code>${name}</code> is replaced with the capture of that name.
</div>
<a name="RegexMatch-foreach"></a><b>
foreach([index], capture, message)
</b>
<p>
<div class=slotDescription>
Loops through the captures, assigns each capture to <em>capture</em>, and evaluates <em>message</em>.
	Returns a list with the result of each evaluation.
</div>
<a name="RegexMatch-indexOf"></a><b>
indexOf(name)
</b>
<p>
<div class=slotDescription>
Returns the index of the capture with the given name.
</div>
<a name="RegexMatch-map"></a><b>
map([index], capture, message)
</b>
<p>
<div class=slotDescription>
Like <code>foreach</code>, but the result of each evaluation of <em>message</em> is returned in a list.
</div>
<a name="RegexMatch-nameOf"></a><b>
nameOf(index)
</b>
<p>
<div class=slotDescription>
Returns the name of the capture with the given index.
</div>
<a name="RegexMatch-names"></a><b>
names
</b>
<p>
<div class=slotDescription>
Returns a list of the name of each named capture.
	If there are no named captures, the list will be empty.
</div>
<a name="RegexMatch-postfix"></a><b>
postfix
</b>
<p>
<div class=slotDescription>
Returns a slice of the subject string that contains all text after this match.
	Equivalent to:
	<pre>
	match subject slice(match end)
	</pre>
</div>
<a name="RegexMatch-prefix"></a><b>
prefix
</b>
<p>
<div class=slotDescription>
Returns a slice of the subject string that contains all text before this match.
	Equivalent to:
	<pre>
	match subject slice(0, match start)
	</pre>
</div>
<a name="RegexMatch-range"></a><b>
range
</b>
<p>
<div class=slotDescription>
Returns the range of the match in the subject.
</div>
<a name="RegexMatch-rangeOf"></a><b>
rangeOf(indexOrName)
</b>
<p>
<div class=slotDescription>
Returns the range of the capture with the given index or name.
</div>
<a name="RegexMatch-ranges"></a><b>
ranges
</b>
<p>
<div class=slotDescription>
Returns a list containing the range of each capture.
</div>
<a name="RegexMatch-regex"></a><b>
regex
</b>
<p>
<div class=slotDescription>
Returns the Regex that was used to find this match.
</div>
<a name="RegexMatch-select"></a><b>
select([index], capture, message)
</b>
<p>
<div class=slotDescription>
Like <code>foreach</code>, but the values for which the result of evaluating <em>message</em> are non-nil are returned
	in a list.
</div>
<a name="RegexMatch-size"></a><b>
size
</b>
<p>
<div class=slotDescription>
Returns the number of captures.
</div>
<a name="RegexMatch-sizeInChars"></a><b>
sizeInChars
</b>
<p>
<div class=slotDescription>
Returns the length of the match, in characters.
</div>
<a name="RegexMatch-slice"></a><b>
slice(startIndex, [endIndex])
</b>
<p>
<div class=slotDescription>
Returns a new list containing the subset of the receiver from the <em>startIndex</em> to the <em>endIndex</em>.
	The <em>endIndex</em> argument is optional. If not given, it is assumed to be the end of the capture list.
</div>
<a name="RegexMatch-start"></a><b>
start
</b>
<p>
<div class=slotDescription>
Returns the index into the subject at which the match starts.
</div>
<a name="RegexMatch-startOf"></a><b>
startOf(indexOrName)
</b>
<p>
<div class=slotDescription>
Returns the index into the subject at which the capture with the given index or name starts.
</div>
<a name="RegexMatch-string"></a><b>
string
</b>
<p>
<div class=slotDescription>
Returns the matched string.
</div>
<a name="RegexMatch-subject"></a><b>
subject
</b>
<p>
<div class=slotDescription>
Returns the string that this match was found in.
</div>
</td>
</tr>
</table>
<br><br><br><br><br>
